<!DOCTYPE html>
<html lang="ru">
<head>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <meta charset="UTF-8">
  <title>SportGate Tap Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      touch-action: manipulation;
      font-family: sans-serif;
      background-color: #008000;
    }

    #score, #title {
      position: absolute;
      left: 20px;
      z-index: 10;
      color: white;
      text-shadow: 1px 1px 4px black;
      user-select: none;
    }

    #score {
      top: 40px;
      font-size: 24px;
      font-weight: bold;
    }

    #title {
      top: 10px;
      font-size: 20px;
      font-weight: bold;
      color: #ffeb3b;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
  </style>
</head>
<body>
  <div id="title">Hi SportGate.io</div>
  <div id="score">Tokens: 0</div>
  <canvas id="gameCanvas"></canvas>

  <script>
    window.onload = () => {
      const tg = window.Telegram.WebApp;
      tg.ready(); // Инициализация WebApp
      const user = tg.initDataUnsafe.user;
      if (user) {
        const username = user.username || `${user.first_name} ${user.last_name || ''}`;
        document.getElementById("title").textContent = `Hi ${username}!`;
      }
	  
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let score = 0;
	  const floatingTexts = [];
	  const fireworks = [];
      const balls = [];
      const goal = {};
      const goalkeeper = {};

      function resizeCanvas() {
        canvas.width = document.documentElement.clientWidth;
        canvas.height = document.documentElement.clientHeight;
		
		const scoreDisplay = document.getElementById("score");
		const scoreRect = scoreDisplay.getBoundingClientRect();
		
		// Ворота
        goal.x = canvas.width / 2 - 200;
        goal.y = scoreRect.bottom + 85; // 85 пикселей ниже очков
        goal.width = 400;
        goal.height = 40;
		
        goalkeeper.radius = 18;
        goalkeeper.x = canvas.width / 2 - 15;
        goalkeeper.y = goal.y + goal.height + 10;
        goalkeeper.speedX = 1.5;
        goalkeeper.direction = 1;

		

      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function spawnBall() {
        balls.push({
          x: canvas.width / 2,
          y: canvas.height - 50,
          radius: 20,
          speedY: -10,
          angle: 0,
          active: true
        });
      }

      canvas.addEventListener("click", spawnBall);
      canvas.addEventListener("touchstart", spawnBall);

function spawnFloatingText(text, x, y, color = "white") {
  floatingTexts.push({
    text,
    x,
    y,
    alpha: 1,
    dy: -1.2,
    color
  });
}

function updateFloatingTexts() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y += t.dy;
    t.alpha -= 0.02;
    if (t.alpha <= 0) {
      floatingTexts.splice(i, 1);
    }
  }
}

function drawFloatingTexts() {
  floatingTexts.forEach(t => {
    ctx.save();
    ctx.font = "bold 36px sans-serif";
    ctx.fillStyle = t.color;
    ctx.globalAlpha = t.alpha;

    // Добавим лёгкую тень
    ctx.shadowColor = "black";
    ctx.shadowBlur = 4;

    ctx.fillText(t.text, t.x, t.y);

    // Сброс эффектов
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  });
}

function colorToRGB(color) {
  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.fillStyle = color;
  const rgb = tempCtx.fillStyle.match(/\d+/g).slice(0, 3);
  return rgb.join(",");
}

function spawnFirework(x, y) {
  for (let i = 0; i < 40; i++) {
    fireworks.push({
      x: x,
      y: y,
      radius: 2 + Math.random() * 3,
      angle: Math.random() * 2 * Math.PI,
      speed: 2 + Math.random() * 4,
      alpha: 1,
      color: getBrightColor()
    });
  }
}

function getBrightColor() {
  const colors = [
    "rgb(255, 255, 255)", // белый
    "rgb(255, 255, 0)",   // жёлтый
    "rgb(0, 191, 255)",   // голубой
    "rgb(255, 105, 180)", // розовый
    "rgb(0, 255, 0)"      // зелёный
  ];
  return colors[Math.floor(Math.random() * colors.length)];
}

function updateFireworks() {
  for (let i = fireworks.length - 1; i >= 0; i--) {
    const p = fireworks[i];
    p.x += Math.cos(p.angle) * p.speed;
    p.y += Math.sin(p.angle) * p.speed;
    p.alpha -= 0.02;
    if (p.alpha <= 0) {
      fireworks.splice(i, 1);
    }
  }
}

function drawFireworks() {
  fireworks.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fillStyle = `${p.color.replace("rgb", "rgba").replace(")", `, ${p.alpha})`)}`;
    ctx.fill();
  });
}

function hslToRgb(hslColor) {
  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.fillStyle = hslColor;
  const rgb = tempCtx.fillStyle.match(/\d+/g).slice(0, 3);
  return rgb.join(",");
}

function drawGoal() {
  const postWidth = 10;
  const postHeight = goal.height + 40; // Удлиненные стойки
  const crossbarHeight = 10;

  // Цвет стоек и перекладины
  ctx.fillStyle = "#FFFFFF";

  // Левая стойка — от перекладины до низа ворот
  ctx.fillRect(goal.x, goal.y - postHeight, postWidth, postHeight+40);

  // Правая стойка
  ctx.fillRect(goal.x + goal.width - postWidth, goal.y - postHeight, postWidth, postHeight + 40);

  // Перекладина
  ctx.fillRect(goal.x, goal.y - postHeight, goal.width, crossbarHeight);
  
    // Перекладина вторая
  ctx.fillRect(goal.x, goal.y, goal.width, crossbarHeight);

  // Сетка ворот — от нижней части до перекладины
  ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
  const gridSize = 8;
  for (let x = goal.x+5; x < goal.x + goal.width - 5; x += gridSize) {
    for (let y = goal.y-5; y > goal.y - postHeight + crossbarHeight; y -= gridSize) {
      ctx.strokeRect(x, y, gridSize, gridSize);
    }
  }

  // Обводка ворот (нижняя часть)
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.strokeRect(goal.x+1, goal.y, goal.width-2, goal.height);
}
      function drawGoalkeeper() {
	    // Тело — вертикальный овал
		ctx.beginPath();
		ctx.ellipse(
			goalkeeper.x, // центр по X
			goalkeeper.y, // чуть ниже головы
			goalkeeper.radius * 2, // ширина тела (уже чем голова)
			goalkeeper.radius * 0.6,   // высота тела (в 2 раза длиннее головы)
			0, 0, Math.PI * 2
		);
		ctx.fillStyle = "darkred";
		ctx.fill();
  
		// Голова вратаря
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.arc(goalkeeper.x, goalkeeper.y, goalkeeper.radius, 0, Math.PI * 2);
        ctx.fill();

      }

      function updateGoalkeeper() {
        goalkeeper.x += goalkeeper.speedX * goalkeeper.direction;
        if (
          goalkeeper.x + goalkeeper.radius > goal.x + goal.width ||
          goalkeeper.x - goalkeeper.radius < goal.x
        ) {
          goalkeeper.direction *= -1;
        }
      }

      function drawHexagon(ctx, x, y, size) {
        const offset = Math.PI / 6;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = offset + i * Math.PI / 3;
          const px = x + size * Math.cos(angle);
          const py = y + size * Math.sin(angle);
          i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      function drawBall(ball) {
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.angle);
        ctx.beginPath();
        ctx.fillStyle = "white";
        ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.stroke();

        ctx.fillStyle = "black";
		
        drawHexagon(ctx, -7, -7, 6);
        drawHexagon(ctx, 8, -5, 6);
        drawHexagon(ctx, 0, 9, 6);

        ctx.restore();
      }

      function updateBalls() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          if (ball.active) {
            ball.y += ball.speedY;
            ball.angle += 0.1;

            const dx = ball.x - goalkeeper.x;
            const dy = ball.y - goalkeeper.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < ball.radius + goalkeeper.radius) {
			  spawnFloatingText("X", ball.x, ball.y, "#ff4444"); // красный
              ball.active = false;
              balls.splice(i, 1);
              continue;
            }

            if (
              ball.y - ball.radius < goal.y + goal.height &&
              ball.x > goal.x &&
              ball.x < goal.x + goal.width
            ) {
			  spawnFirework(ball.x, goal.y + goal.height / 2);
			  const randX = goal.x + Math.random() * goal.width;
			  const randY = Math.random() * canvas.height * 0.6; // верхняя часть экрана
			  spawnFloatingText("+1", randX, randY, "rgb(255, 255, 255)");
              score += 1;
              document.getElementById("score").textContent = "Tokens: " + score;
              ball.active = false;
              balls.splice(i, 1);
            } else if (ball.y + ball.radius < 0) {
              ball.active = false;
              balls.splice(i, 1);
            }
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawFloatingTexts();
		updateFloatingTexts();
		drawFireworks();
		updateFireworks();
        drawGoal();
        drawGoalkeeper();
        balls.forEach(drawBall);
        updateBalls();
        updateGoalkeeper();
        requestAnimationFrame(draw);
      }

      draw();
    };
  </script>
</body>
</html>
