<!DOCTYPE html>
<html lang="ru">
<head>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <meta charset="UTF-8">
  <title>SportGate Tap Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      touch-action: manipulation;
      font-family: sans-serif;
      background-color: #008000;
    }

    #score, #title {
      position: absolute;
      left: 20px;
      z-index: 10;
      color: white;
      text-shadow: 1px 1px 4px black;
      user-select: none;
    }

    #score {
      top: 40px;
      font-size: 24px;
      font-weight: bold;
    }

    #title {
      top: 10px;
      font-size: 20px;
      font-weight: bold;
      color: #ffffff;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
    }
  </style>
</head>
<body>
  <div id="title">Player SportGate.io</div>
  <div id="score">Tokens: 0</div>
  <canvas id="gameCanvas"></canvas>

  <!-- Тег audio для звука гола -->
  <audio id="goalSound" preload="auto">
    <source src="goal_sound.mp3" type="audio/mpeg">
  </audio>
  
    <!-- Тег audio для звука сейва -->
  <audio id="saveSound" preload="auto">
    <source src="save_sound.mp3" type="audio/mpeg">
  </audio>

  <script>
    window.onload = () => {
      const tg = window.Telegram.WebApp;
      tg.ready(); // Инициализация WebApp
      const user = tg.initDataUnsafe.user;
      if (user) {
        const username = user.username || `${user.first_name} ${user.last_name || ''}`;
        document.getElementById("title").textContent = `Player: ${username}`;
      }
	  
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
	  
	  const goalSound = document.getElementById('goalSound');
	  const saveSound = document.getElementById('saveSound');

	  // Обработчики тача
	  canvas.addEventListener("touchstart", () => {
	    lastTouchTime = Date.now();
	    showIdleCircle = false;
	  });
	  
	  canvas.addEventListener("mousedown", () => {
	    lastTouchTime = Date.now();
	    showIdleCircle = false;
	  });

      let score = 0;
	  let idlePulse = 0;
	  let jumpOffset = 0;
	  let armOffset = 0;
	  let legOffset = 0;
	  let sadTimer = 0
	  let lastTouchTime = Date.now();
	  let showIdleCircle = false;
	  const floatingTexts = [];
	  const fireworks = [];
      const balls = [];
      const goal = {};
      const goalkeeper = {};

      function resizeCanvas() {
        canvas.width = document.documentElement.clientWidth;
        canvas.height = document.documentElement.clientHeight;
		
		const scoreDisplay = document.getElementById("score");
		const scoreRect = scoreDisplay.getBoundingClientRect();
		
		// Ворота
        goal.x = canvas.width / 2 - 200;
        goal.y = scoreRect.bottom + 85; // 85 пикселей ниже очков
        goal.width = 400;
        goal.height = 40;
		
        goalkeeper.radius = 18;
        goalkeeper.x = canvas.width / 2 - 15;
        goalkeeper.y = goal.y + goal.height + 10;
        goalkeeper.speedX = 1.5;
        goalkeeper.direction = 1;

		

      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

// Простая функция воспроизведения звука
function playSound(soundElement) {
  try {
    soundElement.currentTime = 0; // Перематываем на начало
    soundElement.play().catch(error => {
      console.log("Не удалось воспроизвести звук:", error);
    });
  } catch (error) {
    console.log("Ошибка воспроизведения звука:", error);
  }
}

// Функции для конкретных звуков
function playGoalSound() {
  playSound(goalSound);
}

function playSaveSound() {
  playSound(saveSound);
}

// Принудительно запускаем загрузку звуков
function preloadSounds() {
  try {
    // Создаем небольшой контекст для предзагрузки
    goalSound.volume = 0;
    saveSound.volume = 0;
    
    goalSound.play().then(() => {
      goalSound.pause();
      goalSound.currentTime = 0;
      goalSound.volume = 1;
      console.log("Goal sound preloaded");
    }).catch(e => console.log("Goal preload error:", e));
    
    saveSound.play().then(() => {
      saveSound.pause();
      saveSound.currentTime = 0;
      saveSound.volume = 1;
      console.log("Save sound preloaded");
    }).catch(e => console.log("Save preload error:", e));
    
  } catch (error) {
    console.log("Preload error:", error);
  }
}

// Вызываем предзагрузку
setTimeout(preloadSounds, 1000); // Даем странице немного времени на загрузку

function spawnBall(event) {
  // Получаем координаты нажатия
  let clientX, clientY;
  
  if (event.type === 'touchstart') {
    clientX = event.touches[0].clientX;
    clientY = event.touches[0].clientY;
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }
  
  // Ограничиваем точку выстрела нижней частью экрана (ниже центра)
  const minY = canvas.height * 0.7; // 70% от высоты экрана
  const spawnY = Math.max(clientY, minY);
  
  // Ограничиваем точку выстрела шириной ворот
  const minX = goal.x + 20; // немного отступаем от края ворот
  const maxX = goal.x + goal.width - 20;
  const spawnX = Math.min(Math.max(clientX, minX), maxX);
  
  // Создаем мяч в ограниченных координатах
  balls.push({
    x: spawnX,
    y: spawnY,
    radius: 20,
    speedY: -10,
    angle: 0,
    active: true
  });
}

canvas.addEventListener("click", function(event) {
  event.preventDefault();
  spawnBall(event);
  lastTouchTime = Date.now();
  showIdleCircle = false;
});

canvas.addEventListener("touchstart", function(event) {
  event.preventDefault();
  spawnBall(event);
  lastTouchTime = Date.now();
  showIdleCircle = false;
});

function spawnFloatingText(text, x, y, color = "white") {
  floatingTexts.push({
    text,
    x,
    y,
    alpha: 1,
    dy: -1.2,
    color
  });
}

function updateFloatingTexts() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y += t.dy;
    t.alpha -= 0.02;
    if (t.alpha <= 0) {
      floatingTexts.splice(i, 1);
    }
  }
}

function drawFloatingTexts() {
  floatingTexts.forEach(t => {
    ctx.save();
    ctx.font = "bold 36px sans-serif";
    ctx.fillStyle = t.color;
    ctx.globalAlpha = t.alpha;

    // Добавим лёгкую тень
    ctx.shadowColor = "black";
    ctx.shadowBlur = 4;

    ctx.fillText(t.text, t.x, t.y);

    // Сброс эффектов
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  });
}

function colorToRGB(color) {
  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.fillStyle = color;
  const rgb = tempCtx.fillStyle.match(/\d+/g).slice(0, 3);
  return rgb.join(",");
}

function spawnFirework(x, y) {
  for (let i = 0; i < 40; i++) {
    fireworks.push({
      x: x,
      y: y,
      radius: 2 + Math.random() * 3,
      angle: Math.random() * 2 * Math.PI,
      speed: 2 + Math.random() * 4,
      alpha: 1,
      color: getBrightColor()
    });
  }
}

function getBrightColor() {
  const colors = [
    "rgb(255, 255, 255)", // белый
    "rgb(255, 255, 0)",   // жёлтый
    "rgb(0, 191, 255)",   // голубой
    "rgb(255, 105, 180)", // розовый
    "rgb(0, 255, 0)"      // зелёный
  ];
  return colors[Math.floor(Math.random() * colors.length)];
}

function updateFireworks() {
  for (let i = fireworks.length - 1; i >= 0; i--) {
    const p = fireworks[i];
    p.x += Math.cos(p.angle) * p.speed;
    p.y += Math.sin(p.angle) * p.speed;
    p.alpha -= 0.02;
    if (p.alpha <= 0) {
      fireworks.splice(i, 1);
    }
  }
}

function drawFireworks() {
  fireworks.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fillStyle = `${p.color.replace("rgb", "rgba").replace(")", `, ${p.alpha})`)}`;
    ctx.fill();
  });
}

function getRandomPlusColor() {
  const colors = [
    "rgb(255, 255, 255)", // белый
    "rgb(255, 255, 0)",   // жёлтый
    "rgb(0, 191, 255)",   // голубой
    "rgb(144, 238, 144)"  // салатовый (light green)
  ];
  return colors[Math.floor(Math.random() * colors.length)];
}

function hslToRgb(hslColor) {
  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCtx.fillStyle = hslColor;
  const rgb = tempCtx.fillStyle.match(/\d+/g).slice(0, 3);
  return rgb.join(",");
}

function drawFieldStripes() {
  const stripeCount = 6; // количество полос
  const stripeWidth = canvas.width / stripeCount;
  const colors = ["#228B22", "#6DBE45"]; // обновлённые зелёные оттенки

  for (let i = 0; i < stripeCount; i++) {
    ctx.fillStyle = colors[i % 2];
    ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height);
  }
}

function drawGoal() {
  const postWidth = 10;
  const postHeight = goal.height + 40; // Удлиненные стойки
  const crossbarHeight = 10;

  // Цвет стоек и перекладины
  ctx.fillStyle = "#FFFFFF";

  // Левая стойка — от перекладины до низа ворот
  ctx.fillRect(goal.x, goal.y - postHeight, postWidth, postHeight+40);

  // Правая стойка
  ctx.fillRect(goal.x + goal.width - postWidth, goal.y - postHeight, postWidth, postHeight + 40);

  // Перекладина
  ctx.fillRect(goal.x, goal.y - postHeight, goal.width, crossbarHeight);
  
    // Перекладина вторая
  ctx.fillRect(goal.x, goal.y, goal.width, crossbarHeight);

  // Сетка ворот — от нижней части до перекладины
  ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
  const gridSize = 8;
  for (let x = goal.x+5; x < goal.x + goal.width - 5; x += gridSize) {
    for (let y = goal.y-5; y > goal.y - postHeight + crossbarHeight; y -= gridSize) {
      ctx.strokeRect(x, y, gridSize, gridSize);
    }
  }

  // Обводка ворот (нижняя часть)
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.strokeRect(goal.x+1, goal.y, goal.width-2, goal.height);
}

function drawGoalkeeper() {
  ctx.save();
  ctx.translate(0, jumpOffset); // анимация прыжка
  const skinColor = "#F4C2C2"; // светлый телесный (можно заменить на другой оттенок)

  // Майка (верх туловища)
  ctx.fillStyle = "#A9A9A9"; // серая
  ctx.fillRect(goalkeeper.x - 10, goalkeeper.y, 20, 25);
  ctx.font = "bold 16px sans-serif";
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.fillText("0", goalkeeper.x, goalkeeper.y + 18);
  
  // Шорты
  ctx.fillStyle = "#00BFFF"; // голубые
  ctx.fillRect(goalkeeper.x - 10, goalkeeper.y + 25, 20, 15);
  
  // Голова
  ctx.beginPath();
  ctx.arc(goalkeeper.x, goalkeeper.y - 10, 12, 0, Math.PI * 2);
  ctx.fillStyle = skinColor;
  ctx.fill();

  // Глаза
  ctx.beginPath();
  ctx.arc(goalkeeper.x - 5, goalkeeper.y - 23, 5, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
  ctx.beginPath();
  ctx.arc(goalkeeper.x - 5, goalkeeper.y - 23, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(goalkeeper.x + 5, goalkeeper.y - 23, 5, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
  ctx.beginPath();
  ctx.arc(goalkeeper.x + 5, goalkeeper.y - 23, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();

  // Руки
  ctx.fillStyle = skinColor;
  ctx.fillRect(goalkeeper.x - 25, goalkeeper.y + 5 + armOffset, 15, 8); // левая
  ctx.fillRect(goalkeeper.x + 10, goalkeeper.y + 5 + armOffset, 15, 8); // правая

  // Перчатки
  ctx.beginPath();
  ctx.arc(goalkeeper.x - 30, goalkeeper.y + 9 + armOffset, 6, 0, Math.PI * 2);
  ctx.fillStyle = "#FFD700";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(goalkeeper.x + 30, goalkeeper.y + 9 + armOffset, 6, 0, Math.PI * 2);
  ctx.fillStyle = "#FFD700";
  ctx.fill();

  // Ноги
  ctx.fillStyle = skinColor;
  ctx.fillRect(goalkeeper.x - 8, goalkeeper.y + 40 + legOffset, 6, 10);
  ctx.fillRect(goalkeeper.x + 2, goalkeeper.y + 40 - legOffset, 6, 10);

  // Бутсы
  ctx.fillStyle = "black";
  ctx.fillRect(goalkeeper.x - 8, goalkeeper.y + 50 + legOffset, 6, 5);
  ctx.fillRect(goalkeeper.x + 2, goalkeeper.y + 50 - legOffset, 6, 5);
  
  // Эмоции — рот
  if (sadTimer > 0) {
    ctx.beginPath();
    ctx.arc(goalkeeper.x, goalkeeper.y - 5, 6, Math.PI, 2 * Math.PI); // грустный рот
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();
    sadTimer--;
  } else {
    ctx.beginPath();
    ctx.arc(goalkeeper.x, goalkeeper.y - 15, 6, 0, Math.PI); // улыбка
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  ctx.restore();
}
      function updateGoalkeeper() {
	    const baseSpeed = 2.5;
        goalkeeper.x += goalkeeper.speedX * goalkeeper.direction;
        if ( goalkeeper.x + goalkeeper.radius > goal.x + goal.width ) { 
		  goalkeeper.direction = -1;
		} else if (goalkeeper.x - goalkeeper.radius < goal.x) {
		  goalkeeper.direction = 1;
		} else {
		  const randomDirection = Math.random();
		  if (randomDirection < 0.01) {
		    goalkeeper.direction = -1; // 40% chance влево
		  } else if (randomDirection > 0.99 ) {
		    goalkeeper.direction = 1; // 40% chance вправо
		  }
		}
		
        // Добавляем немного случайности к скорости
		goalkeeper.speedX = baseSpeed + (Math.random() * 1.5 - 0.75);

		jumpOffset = Math.sin(Date.now() / 200) * 5; // плавное подпрыгивание
		armOffset = Math.sin(Date.now() / 300) * 4; // плавное движение вверх-вниз
		legOffset = Math.sin(Date.now() / 250) * 3; // плавное движение ног
      }

      function drawHexagon(ctx, x, y, size) {
        const offset = Math.PI / 6;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = offset + i * Math.PI / 3;
          const px = x + size * Math.cos(angle);
          const py = y + size * Math.sin(angle);
          i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      function drawBall(ball) {
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.angle);
        ctx.beginPath();
        ctx.fillStyle = "white";
        ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.stroke();

        ctx.fillStyle = "black";
		
        drawHexagon(ctx, -7, -7, 6);
        drawHexagon(ctx, 8, -5, 6);
        drawHexagon(ctx, 0, 9, 6);

        ctx.restore();
      }

      function updateBalls() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          if (ball.active) {
            ball.y += ball.speedY;
            ball.angle += 0.1;

            const dx = ball.x - goalkeeper.x;
            const dy = ball.y - goalkeeper.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < ball.radius + goalkeeper.radius) {
			  playSaveSound();
			  const randX = goal.x + 20 + Math.random() * (goal.width - 40); // внутри ширины ворот
			  const randY = goal.y + goal.height + 30; 
			  spawnFloatingText("X", randX, randY, "#ff4444"); // красный
              ball.active = false;
              balls.splice(i, 1);
              continue;
            }

            if (
              ball.y - ball.radius < goal.y + goal.height &&
              ball.x > goal.x &&
              ball.x < goal.x + goal.width
            ) {
			  playGoalSound();
			  spawnFirework(ball.x, goal.y + goal.height / 2);
			  const randX = goal.x + 20 + Math.random() * (goal.width - 40); // внутри ворот, с небольшим отступом
			  const randY = Math.random() * canvas.height * 0.6; // верхняя часть экрана
			  spawnFloatingText("+1", randX, randY, getRandomPlusColor());
			  sadTimer = 60; // грустит 60 кадров
              score += 1;
              document.getElementById("score").textContent = "Tokens: " + score;
              ball.active = false;
              balls.splice(i, 1);
            } else if (ball.y + ball.radius < 0) {
              ball.active = false;
              balls.splice(i, 1);
            }
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawFieldStripes();
		drawFloatingTexts();
		updateFloatingTexts();
		drawFireworks();
		updateFireworks();
        drawGoal();
        drawGoalkeeper();
        balls.forEach(drawBall);
        updateBalls();
        updateGoalkeeper();
		
		if (Date.now() - lastTouchTime > 3000) {
		  showIdlePrompt = true;
		} else {
		  showIdlePrompt = false;
		}
		
		idlePulse = Math.sin(Date.now() / 500) * 0.3 + 0.7;
		
		if (showIdlePrompt) {
		  ctx.font = "bold 36px sans-serif";
		  ctx.textAlign = "center";
		  ctx.lineWidth = 2;
		  ctx.globalAlpha = idlePulse;

		  // Обводка
		  ctx.strokeStyle = "white";
		  ctx.strokeText("Tap to shoot", canvas.width / 2, canvas.height / 1.5);

		  // Заливка
		  ctx.fillStyle = "white";
		  ctx.fillText("Tap to shoot", canvas.width / 2, canvas.height / 1.5);

		  ctx.globalAlpha = 1;
		}		
        requestAnimationFrame(draw);
      }

      draw();
    };
  </script>
</body>
</html>
